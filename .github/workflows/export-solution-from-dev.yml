name: export-solution-from-dev
# Export solution from DEV environment
#  unpack it and prepare, commit and push a git branch with the changes

on:
  workflow_dispatch:
    inputs:
      # Change this value
      solution_name_choice:
        description: 'Select a solution name (or enter a custom name below to override)'
        required: true
        type: choice
        options:
          # GENERATED-OPTIONS-START
          - ALMLab
          # GENERATED-OPTIONS-END
      solution_name_custom:
        description: 'Optional: enter a custom solution name (overrides the dropdown if set)'
        required: false
        type: string
  # no default; must be specified at dispatch time
      # Do Not change these values
      solution_exported_folder:
        description: 'folder name for staging the exported solution *do not change*'
        required: true
        default: out/exported/
      solution_folder:
        description: 'staging the unpacked solution folder before check-in *do not change*'
        required: true
        default: out/solutions/
      solution_target_folder:
        description: 'folder name to be created and checked in *do not change*'
        required: true
        default: solutions/

# edit your values here
env:
  ENVIRONMENT_URL: ${{ secrets.ENVIRONMENTURL_DEV }}
  CLIENT_ID: ${{ secrets.POWERPLATFORM_APPID }}
  TENANT_ID: ${{ secrets.TENANTID }}

permissions:
  contents: write

jobs:
  export-from-dev:
    runs-on: windows-latest
    # or you can say runs-on: ubuntu-latest
    env:
      RUNNER_DEBUG: 1

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Resolve solution name (custom overrides dropdown)
        id: resolve
        shell: pwsh
        run: |
          $choice = "${{ github.event.inputs.solution_name_choice }}"
          $custom = "${{ github.event.inputs.solution_name_custom }}"
          if ($custom -and $custom.Trim() -ne '') { $val = $custom } else { $val = $choice }
          if ((-not $custom) -or ($custom.Trim() -eq '')) {
            if ($choice -eq '<none>') {
              Write-Error "No solution selected. Provide a custom solution name or select a real solution instead of <none>."
              exit 1
            }
          }
          $val = $val.Trim()
          # Make available as environment variable for subsequent script steps
          "SOLUTION_NAME=$val" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          # Also expose as a step output for use in expressions
          "solution_name=$val" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Install Power Platform CLI
        uses: microsoft/powerplatform-actions/actions-install@v1

      - name: Who am I
        uses: microsoft/powerplatform-actions/who-am-i@v1
        with:
          environment-url: ${{env.ENVIRONMENT_URL}}
          app-id: ${{env.CLIENT_ID}}
          client-secret: ${{ secrets.POWERPLATFORMSPN }}
          tenant-id: ${{env.TENANT_ID}}

      - name: Export Solution
        uses: microsoft/powerplatform-actions/export-solution@v1
        with:
          environment-url: ${{env.ENVIRONMENT_URL}}
          app-id: ${{env.CLIENT_ID}}
          client-secret: ${{ secrets.POWERPLATFORMSPN }}
          tenant-id: ${{env.TENANT_ID}}
          solution-name: ${{ steps.resolve.outputs.solution_name }}
          solution-output-file: ${{ github.event.inputs.solution_exported_folder}}/${{ steps.resolve.outputs.solution_name }}.zip

      - name: Unpack Solution
        uses: microsoft/powerplatform-actions/unpack-solution@v1
        with:
          solution-file: ${{ github.event.inputs.solution_exported_folder}}/${{ steps.resolve.outputs.solution_name }}.zip
          solution-folder: ${{ github.event.inputs.solution_folder}}/${{ steps.resolve.outputs.solution_name }}
          solution-type: 'Unmanaged'
          overwrite-files: true

      - name: Read solution version
        id: version
        shell: pwsh
        run: |
          $file = Join-Path -Path "${{ github.event.inputs.solution_folder}}" -ChildPath "${{ steps.resolve.outputs.solution_name }}"
          $file = Join-Path -Path $file -ChildPath 'Other/Solution.xml'
          if (-not (Test-Path -Path $file)) {
            Write-Host "Solution.xml not found at $file. Falling back to timestamp-based version."
            $version = (Get-Date -Format 'yyyy.MM.dd.HHmmss')
          } else {
            try {
              [xml]$xml = Get-Content -Path $file -Encoding UTF8
              $version = $xml.ImportExportXml.SolutionManifest.Version
              if (-not $version -or "$version".Trim() -eq '') { $version = (Get-Date -Format 'yyyy.MM.dd.HHmmss') }
            } catch {
              Write-Host "Failed to parse version from Solution.xml. Using timestamp. $_"
              $version = (Get-Date -Format 'yyyy.MM.dd.HHmmss')
            }
          }
          "SOLUTION_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Create release tag on main
        shell: bash
        env:
          SOLUTION_NAME: ${{ steps.resolve.outputs.solution_name }}
          SOLUTION_VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # Ensure we have up-to-date refs
          git fetch --no-tags origin main
          git fetch --tags origin
          MAIN_SHA=$(git rev-parse origin/main)
          TAG="solution/${SOLUTION_NAME}@${SOLUTION_VERSION}"
          echo "Preparing tag '$TAG' for commit $MAIN_SHA (main)."
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists. Skipping creation."
            exit 0
          fi
          git tag -a "$TAG" "$MAIN_SHA" -m "Exported ${SOLUTION_NAME} version ${SOLUTION_VERSION}"
          git push origin "$TAG"

      - name: Ensure solutions.json includes exported solution
        id: ensure_json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const sol = process.env.SOLUTION_NAME;
            const file = path.join(process.env.GITHUB_WORKSPACE, 'solutions.json');
            let changed = false;
            let arr = [];
            if (fs.existsSync(file)) {
              try { arr = JSON.parse(fs.readFileSync(file, 'utf8')) || []; } catch {}
            }
            if (!Array.isArray(arr)) arr = [];
            const names = new Set(arr.map(s => String(s).trim()).filter(Boolean));
            if (!names.has(sol)) {
              names.add(sol);
              const out = Array.from(names).sort();
              fs.writeFileSync(file, JSON.stringify(out, null, 2) + '\n');
              changed = true;
            }
            // github-script automatically sets the 'result' output to the returned value
            return String(changed);
        env:
          SOLUTION_NAME: ${{ steps.resolve.outputs.solution_name }}

      - name: Open PR to add solution to solutions.json (if needed)
        if: ${{ steps.ensure_json.outputs.result == 'true' }}
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: main
          commit-message: "chore: add ${{ steps.resolve.outputs.solution_name }} to solutions.json"
          title: "chore: add ${{ steps.resolve.outputs.solution_name }} to solutions.json"
          body: |
            This PR adds the solution name `${{ steps.resolve.outputs.solution_name }}` to `solutions.json` so it appears in dropdowns.
          branch: chore/add-solution-${{ steps.resolve.outputs.solution_name }}-to-json
          delete-branch: true

      - name: Branch Solution for Pull Request
        uses: microsoft/powerplatform-actions/branch-solution@v1
        with:
          solution-folder: ${{ github.event.inputs.solution_folder}}/${{ steps.resolve.outputs.solution_name }}
          solution-target-folder: ${{ github.event.inputs.solution_target_folder}}/${{ steps.resolve.outputs.solution_name }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          allow-empty-commit: true
